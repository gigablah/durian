{"name":"Durian","tagline":"A PHP 5.5 microframework based on generator-style middleware.","body":"Durian\r\n======\r\n\r\nA pungent PHP 5.5 microframework based on generator-style middleware.\r\n\r\nWhy?\r\n----\r\n\r\nBecause I can.\r\n\r\nInstallation\r\n------------\r\n\r\nUse [Composer][1] to install the gigablah/durian library by adding it to your `composer.json`.\r\n\r\n```json\r\n{\r\n    \"require\": {\r\n        \"gigablah/durian\": \"~0.0.2\"\r\n    }\r\n}\r\n```\r\n\r\nUsage\r\n-----\r\n\r\n```php\r\n$app = new Durian\\Application();\r\n$app->route('/hello/{name}', function () {\r\n    return 'Hello '.$this->param('name');\r\n});\r\n$app->run(Symfony\\Component\\HttpFoundation\\Request::createFromGlobals());\r\n```\r\n\r\nNothing special there. The `Application` container is based on [Pimple][2] and inherits its functions for defining lazy loading services. We also make use of the Symfony2 `Request` object so you have access to request headers, parameters and cookies. But since this is a PHP 5.5 microframework, it has been tailored to take advantage of shiny new [generator functions][3]. We'll explore that starting with `Application::route`.\r\n\r\nRouting\r\n-------\r\n\r\n```php\r\n$app['awesome_library'] = $app->share(function ($app) {\r\n    return new MyAwesomeLibrary();\r\n});\r\n\r\n$app->route('/hello', function () use ($app) {\r\n    $app['awesome_library']->performExpensiveOperation();\r\n    yield 'Hello ';\r\n    $app['awesome_library']->performCleanUp();\r\n})->route('/{name}', function () {\r\n    return $this->last().$this->param('name');\r\n})->get(function () {\r\n    return ['method' => 'GET', 'message' => $this->last()];\r\n})->post(function () {\r\n    return ['method' => 'POST', 'message' => $this->last()];\r\n});\r\n```\r\n\r\nInstead of the hierarchical routing syntax found in some other microframeworks, we use method chaining. The `yield` keyword allows us to pass execution to the next matching segment. Upon reaching the end of the chain, the execution flow is passed back to all generators in reverse order. Therefore, code before and after a `yield` statement will essentially \"wrap\" subsequent route handlers.\r\n\r\nWhy method chaining? The simple reason is that embedding the next route or method segment inside the route handler function forces us to execute the handler first before proceeding, thus potentially incurring expensive initialization code even if the request results in an error. Here, we stack the handler functions as each segment matches, and execute all of them in one go only if the route and method match is successful.\r\n\r\n(At least, that was the original intention. Currently the framework utilizes [nikic/fast-route][4], which compiles all the routes into a single regex that maps to handler stack combinations.)\r\n\r\nNote that `Application::route` starts a new segment and returns a new `Route` object. The method functions map to all the common HTTP request methods (get, post, put, delete, patch, options) and return the same `Route`. All the routing methods accept an arbitrary number of handler functions, so you can encapsulate surrounding operations (such as the ones in the example above) into a separate generator:\r\n\r\n```php\r\n$expensiveOperation = function () use ($app) {\r\n    $app['awesome_library']->performExpensiveOperation();\r\n    yield;\r\n    $app['awesome_library']->performCleanUp();\r\n};\r\n\r\n$app->route('/hello', $expensiveOperation, function () {\r\n    return 'Hello ';\r\n})->route(...);\r\n```\r\n\r\nYou don't necessarily have to chain route segments, the old-fashioned way of defining entire paths will still work fine:\r\n\r\n```php\r\n// Routes will support GET by default\r\n$app->route('/users');\r\n\r\n// Methods can be declared without handlers\r\n$app->route('/users/{name}')->post();\r\n\r\n// Declare multiple methods separated by pipe characters\r\n$app->route('/users/{name}/friends')->method('GET|POST');\r\n```\r\n\r\nReturn values are automatically converted to Symfony2 `Response` objects. Arrays will result in a `JsonResponse`. You may also manually craft a response:\r\n\r\n```php\r\n$app->route('/tea', function () use ($app) {\r\n    $this->response(\"I'm a teapot\", 418);\r\n});\r\n```\r\n\r\nOr throw an exception:\r\n\r\n```php\r\n$app->route('/404', function () {\r\n    // Alternatively pass in an exception object as the first parameter\r\n    $this->error('Not Found', 404);\r\n});\r\n```\r\n\r\nSubrequests are performed by calling `Application::run`:\r\n\r\n```php\r\n$app->route('/song/{id:[0-9]+}', function () use ($app) {\r\n    $id = $this->param('id');\r\n    return [\r\n        'id' => $id,\r\n        'artist' => $app->run('GET', \"/artists-by-song/$id\")->getContent()\r\n    ];\r\n});\r\n```\r\n\r\nContext\r\n-------\r\n\r\nSee the lavish use of `$this` in the examples above? That's made possible by the automatic binding of each closure or generator to the `Context` object. Each time the application handles a request or subrequest, a new context is pushed onto the stack.\r\n\r\nThe context is a simple container for the `Request` and `Response` objects. It also holds the route parameters and the return values from each handler.\r\n\r\n```php\r\n$app->route('/hello/{name}', function () {\r\n    return $this->param('name');\r\n})->get(function () {\r\n    $name = $this->last();\r\n    $request = $this->request();\r\n    if (!$this->response()) {\r\n        $this->response(\"Hello $name\");\r\n    }\r\n});\r\n```\r\n\r\n`Context::last` holds the return (or yielded) value from the previous handler. This is a way to pass information downstream other than using the application container or request attributes.\r\n\r\nMiddleware\r\n----------\r\n\r\nThe pattern of generator stacking applies to the entire application flow, not just routing. All middlewares boil down to a callable or generator function with an optional test function. They can be defined using `Application::handler`:\r\n\r\n```php\r\n$responseTimeMiddleware = $app->handler(function () {\r\n    $time = microtime(true);\r\n    yield;\r\n    $this->response()->headers->set('X-Response-Time', sprintf('%fms', microtime(true) - $time));\r\n}, function () use ($app) {\r\n    return $this->master() && $app['debug'];\r\n});\r\n```\r\n\r\nThis returns a `Handler` object which can now be added to the front or back of the middleware stack:\r\n\r\n```php\r\n$app->before($responseTimeMiddleware);\r\n$app->after($someOtherMiddleware);\r\n```\r\n\r\nYou can modify the entire stack with `Application::handlers`. The second parameter determines whether to replace the whole stack (true by default).\r\n\r\n```php\r\n$app->handlers([\r\n    $responseTimeMiddleware,\r\n    new Durian\\Middleware\\RouterMiddleware()\r\n]);\r\n```\r\n\r\nMiddleware can also be defined as concrete classes by extending `AbstractMiddleware`.\r\n\r\nHandler Injection\r\n-----------------\r\n\r\nIf a handler function returns another `Handler`, it will be inserted into the current position of the execution stack.\r\n\r\nSimilarly, if a handler function produces a generator that yields handlers, the whole collection will be inserted into the stack. This is exactly how the router middleware works.\r\n\r\nIn essence, the handler stack is recursively iterated over as a multidimensional array.\r\n\r\nException Handling\r\n------------------\r\n\r\nWhenever an exception is thrown, the application bubbles it up through all the generators in the stack.\r\n\r\nThis means that you can intercept any exception by wrapping a `yield` statement with a try/catch block:\r\n\r\n```php\r\n$exceptionHandlerMiddleware = $app->handler(function () {\r\n    try {\r\n        yield;\r\n    } catch (\\Exception $exception) {\r\n        if ($exception instanceof HttpException) {\r\n            $this->response(\r\n                $exception->getMessage(),\r\n                $exception->getStatusCode(),\r\n                $exception->getHeaders()\r\n            );\r\n        } else {\r\n            $this->response($exception->getMessage(), 500);\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nFor pretty exception traces, you can make use of the [filp/whoops][5] library by including it in your composer.json:\r\n\r\n```json\r\n{\r\n    \"require\": {\r\n        \"gigablah/durian\": \"~0.0.2\",\r\n        \"filp/whoops\": \"~1.0\"\r\n    }\r\n}\r\n```\r\n\r\nThen, register `WhoopsMiddleware` as the first handler in your application:\r\n\r\n```php\r\n$app->handlers([\r\n    new Durian\\Middleware\\WhoopsMiddleware()\r\n    new Durian\\Middleware\\RouterMiddleware()\r\n]);\r\n```\r\n\r\nDependency Injection\r\n--------------------\r\n\r\nDependency injection? What's that? :)\r\n\r\nOther than the fact that the application container is based on `Pimple`, a lightweight DIC (or service locator, if you're so inclined), no parameter matching is currently performed on route handlers. Eventually I'd like to have it implemented as an optional trait. Watch this space!\r\n\r\nHttpKernelInterface\r\n-------------------\r\n\r\nThe `Application` container implements Symfony2's `HttpKernelInterface`, so you can compose it with other compatible applications via [Stack][6].\r\n\r\nMethod List\r\n-----------\r\n\r\n### Application\r\n\r\n```php\r\n$app->run($request_or_method, $path);\r\n$app->route($path, ...$handlers);\r\n$app->handler($callable, $optional_callable);\r\n$app->before($callable, $optional_callable);\r\n$app->after($callable, $optional_callable);\r\n$app->handlers($handlers, $replace);\r\n$app->handle($request, $type, $catch);\r\n```\r\n\r\n### Route\r\n\r\n```php\r\n$route->route($path, ...$handlers);\r\n$route->path();\r\n$route->method($methods, ...$handlers);\r\n$route->get(...$handlers);\r\n$route->post(...$handlers);\r\n$route->put(...$handlers);\r\n$route->delete(...$handlers);\r\n$route->patch(...$handlers);\r\n$route->options(...$handlers);\r\n$route->head(...$handlers);\r\n$route->dump();\r\n```\r\n\r\n### Context\r\n\r\n```php\r\n$context->request();\r\n$context->request($request);\r\n$context->response();\r\n$context->response($response);\r\n$context->response($content, $status, $headers);\r\n$context->error($exception);\r\n$context->error($message, $status, $headers, $code);\r\n$context->master();\r\n$context->map($params);\r\n$context->param($key);\r\n$context->param($key, $default);\r\n$context->append($output);\r\n$context->last();\r\n```\r\n\r\nLicense\r\n-------\r\n\r\nReleased under the MIT license. See the LICENSE file for details.\r\n\r\nCredits\r\n-------\r\n\r\nThis project was inspired by the following:\r\n\r\n* [koa][7]\r\n* [Martini][8]\r\n* [Bullet][9]\r\n* [Slim][10]\r\n\r\n[1]: http://getcomposer.org\r\n[2]: http://pimple.sensiolabs.org\r\n[3]: http://www.php.net/manual/en/language.generators.overview.php\r\n[4]: https://github.com/nikic/FastRoute\r\n[5]: https://github.com/filp/whoops\r\n[6]: http://stackphp.com\r\n[7]: https://github.com/koajs/koa\r\n[8]: https://github.com/codegangsta/martini\r\n[9]: https://github.com/vlucas/bulletphp\r\n[10]: https://github.com/codeguy/Slim\r\n","google":"UA-48397169-1","note":"Don't delete this file! It's used internally to help with page regeneration."}